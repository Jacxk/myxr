// Generated by AI, it works but idk how...

import * as lamejs from "@breezystack/lamejs";

/**
 * Trims an audio file and converts it to MP3.
 * @param {File} file - The audio file to trim.
 * @param {number} startTime - The start time of the trimmed audio in seconds.
 * @param {number} endTime - The end time of the trimmed audio in seconds.
 * @returns {Promise<File | null>} - A Promise that resolves with the trimmed MP3 file, or null if an error occurs.
 */
export const trimAudioAndConvertToMp3 = async (
  file: File,
  startTime: number,
  endTime: number,
): Promise<File> => {
  const audioContext = new AudioContext();
  const arrayBuffer = await file.arrayBuffer();
  const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

  const sampleRate = audioBuffer.sampleRate;
  const startSample = Math.floor(startTime * sampleRate);
  const endSample = Math.floor(endTime * sampleRate);
  const trimmedAudioBuffer = audioContext.createBuffer(
    audioBuffer.numberOfChannels,
    endSample - startSample,
    sampleRate,
  );

  for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
    const oldChannelData = audioBuffer.getChannelData(i);
    const newChannelData = trimmedAudioBuffer.getChannelData(i);
    newChannelData.set(oldChannelData.subarray(startSample, endSample));
  }

  // Convert to MP3
  const mp3Blob = await encodeMP3(trimmedAudioBuffer);
  const name = `${file.name.split(".").slice(0, -1).join(".")}.mp3`;
  return new File([mp3Blob], name, { type: "audio/mp3" });
};

/**
 * Encodes an AudioBuffer to an MP3 Blob using lamejs.
 * @param {AudioBuffer} audioBuffer - The AudioBuffer to encode.
 * @returns {Promise<Blob>} - A Promise that resolves with the MP3 Blob.
 */
const encodeMP3 = async (audioBuffer: AudioBuffer): Promise<Blob> => {
  return new Promise((resolve) => {
    const numberOfChannels = audioBuffer.numberOfChannels;
    const sampleRate = audioBuffer.sampleRate;
    const bitRate = 96; // You can adjust the bitrate here (kbps) - Lower for smaller file size

    const mp3encoder = new lamejs.Mp3Encoder(
      numberOfChannels,
      sampleRate,
      bitRate,
    );

    let left, right;

    if (numberOfChannels === 1) {
      left = audioBuffer.getChannelData(0);
      right = audioBuffer.getChannelData(0); // Duplicate for mono
    } else {
      left = audioBuffer.getChannelData(0);
      right = audioBuffer.getChannelData(1);
    }

    // Convert to Int16 (LAME requires Int16)
    const leftI16 = floatTo16BitPCM(left);
    const rightI16 = floatTo16BitPCM(right);

    const buffer = [];
    let remaining = leftI16.length;
    const maxSamples = 1152; // Recommended chunk size for LAME

    for (let i = 0; remaining > 0; i += maxSamples) {
      const toEncode = Math.min(remaining, maxSamples);
      const leftChunk = leftI16.subarray(i, i + toEncode);
      const rightChunk = rightI16.subarray(i, i + toEncode);

      const mp3buf = mp3encoder.encodeBuffer(leftChunk, rightChunk);
      if (mp3buf.length > 0) {
        buffer.push(new Int8Array(mp3buf));
      }
      remaining -= toEncode;
    }

    const mp3buf = mp3encoder.flush();
    if (mp3buf.length > 0) {
      buffer.push(new Int8Array(mp3buf));
    }

    const blob = new Blob(buffer, { type: "audio/mp3" });
    resolve(blob);
  });
};

/**
 * Converts a Float32Array to an Int16Array (required by LAME).
 * @param {Float32Array} input - The Float32Array to convert.
 * @returns {Int16Array} - The converted Int16Array.
 */
function floatTo16BitPCM(input: Float32Array): Int16Array {
  const output = new Int16Array(input.length);
  for (let i = 0; i < input.length; i++) {
    const s = Math.max(-1, Math.min(1, input[i] ?? 1));
    output[i] = s < 0 ? s * 0x8000 : s * 0x7fff;
  }
  return output;
}
